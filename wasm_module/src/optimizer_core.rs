use wasm_bindgen::JsValue;
use web_sys::console;

use crate::gw2data::{Affix, Character, Combination};
use std::cell::RefCell;

/// Uses depth-first search to calculate all possible combinations of affixes for the given subtree.
///
/// # Arguments
/// * `affix_array` - An array of vectors of affixes. Each entry in the array corresponds to the affixes selectable for a specific slot. The array is of length 14, because there are 14 slots. However, if the last slot is not used due to two-handed weapons, the last entry in the array is Affix::None
/// * `subtree` - The current subtree of the affix tree. This is a vector of affixes. The length of the vector is the current layer of the tree. The first entry in the vector is the root of the tree.
/// * `leaf_callback` - A function that is called when a leaf of the tree is reached. The function is passed the current subtree.
pub fn descend_subtree_dfs<F>(
    affix_array: &[Vec<Affix>],
    subtree: &[Affix],
    max_depth: usize,
    leaf_callback: &mut F,
) where
    F: FnMut(&[Affix]),
{
    let current_layer = subtree.len();

    if current_layer == max_depth {
        // if we reached leafs of the tree, call the function
        leaf_callback(subtree);
    } else {
        let permutation_options = &affix_array[current_layer];

        let mut new_subtree: Vec<Affix> = Vec::with_capacity(subtree.len() + 1);
        new_subtree.clear();
        new_subtree.extend_from_slice(subtree);

        for &option in permutation_options {
            new_subtree.push(option);
            descend_subtree_dfs(affix_array, &new_subtree, max_depth, leaf_callback);
            new_subtree.pop();
        }
    }
}

/// Starts the optimization process. Calculates all possible combinations for the given chunk (subtree) of the affix tree.
/// This process is independent of the other chunks.
///
/// # Arguments
/// * `chunks` - A vector of vectors of affixes. Each chunk represents a subtree of the affix tree. The chunks are generated by the JS code and distributed to multiple web workers.
/// * `combinations` - A vector of extras combinations. To calculate the best runes and sigils we must calculate the resulting stats for each combination of extras. Also contains important optimizer settings.
pub fn start(chunks: &Vec<Vec<Affix>>, combinations: &Vec<Combination>) -> i32 {
    let counter = RefCell::new(0);
    let mut character = Character::default();

    let affix_array = &combinations[0].affixesArray;
    let affix_stats = &combinations[0].affixStatsArray;
    let max_depth = &combinations[0].slots;

    // this callback is called for every affix combination (leaf). this is where we calculate the resulting stats
    let mut callback = |subtree: &[Affix]| {
        // Leaf callback implementation
        character.clear();

        for (index, affix) in subtree.iter().enumerate() {
            // all of this is neglible compared to base_attributes.add_attributes
            character.set_affix(index, *affix);

            let index_in_affix_array = affix_array[index]
                .iter()
                .position(|&r| r.to_number() == affix.to_number())
                .unwrap();
            let attributes_to_add = &affix_stats[index][index_in_affix_array];

            // this call is expensive!
            character.add_attributes(attributes_to_add);
        }

        *counter.borrow_mut() += 1;
    };

    for chunk in chunks {
        // start dfs into tree
        descend_subtree_dfs(affix_array, &chunk, *max_depth as usize, &mut callback);
    }

    return counter.into_inner();
}
